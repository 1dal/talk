#!/usr/bin/env node

/**
 * Module dependencies.
 */

const program = require('commander');
const pkg = require('../package.json');
const dotenv = require('dotenv');
const fs = require('fs');
const util = require('../util');

//==============================================================================
// Setting up the program command line arguments.
//==============================================================================

program
  .version(pkg.version)
  .option('-c, --config [path]', 'Specify the configuration file to load')
  .option('--pid [path]', 'Specify a path to output the current PID to')
  .parse(process.argv);

if (program.config) {
  let r = dotenv.config({
    path: program.config
  });

  if (r.error) {
    throw r.error;
  }
}

// If the `--pid` flag is used, put the current pid there.
if (program.pid) {
  let pidPath = program.pid;

  if (!/\//.test(pidPath)) {
    if (!/\.pid/.test(pidPath)) {
      pidPath += '.pid';
    }
    pidPath = `/tmp/${pidPath}`;
  }

  fs.writeFile(pidPath, `${process.pid.toString()}\n`, (err) => {
    if (err) {
      console.error(`Can't write PID file: ${err}`);
      throw err;
    }

    // Add the cleanup for the fs onto the shutdown.
    util.onshutdown([
      () => new Promise((resolve, reject) => {

        // Remove the pid file.
        fs.unlink(pidPath, (err) => {
          if (err) {
            return reject(err);
          }

          return resolve();
        });
      })
    ]);
  });
}

// Perform rewrites to the runtime environment variables based on the contents
// of the process.env.REWRITE_ENV if it exists. This is done here as it is the
// entrypoint for the entire application.
require('env-rewrite').rewrite();

program
  .command('serve', 'serve the application')
  .command('assets', 'interact with assets')
  .command('settings', 'work with the application settings')
  .command('jobs', 'work with the job queues')
  .command('users', 'work with the application auth')
  .parse(process.argv);

// If there is no command listed, output help.
if (!process.argv.slice(2).length) {
  program.outputHelp();
  return;
}

// The ensures that the child process that is created here is always cleaned up
// properly when the parent process dies.
util.onshutdown([
  (signal) => {
    if ((program.runningCommand.killed === false) && (program.runningCommand.exitCode === null)) {
      program.runningCommand.kill(signal);
    }
  }
]);
